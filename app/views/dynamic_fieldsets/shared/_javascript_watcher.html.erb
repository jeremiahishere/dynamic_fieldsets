<script type='text/javascript'>

// The only inputs we care about are visible... not hidden
var allInputs = $(":input:not(:hidden)");

/***************************************************************************
   
  field-[group_field]-child-[group_fsc] - just want the last value from the
  input's id. This function rips it.

  input - called upon the input that just called the change()
  returns [integer] - the group_fsc id from the end of the id

***************************************************************************/

function grab_fsc_id(field, type) {
	switch(type)
	{
		case 'text':
			var id_array = field.attr('id').split('-');
			return id_array[id_array.length-1];
		case 'radio':
			var id_array = field.closest("div").attr("id").split('-');
			return id_array[id_array.length-1];
		case 'textarea':
			var id_array = field.attr('id').split('-');
			return id_array[id_array.length-1];
		case 'checkbox':
			var id_array = field.closest("div").attr("id").split('-');
			return id_array[id_array.length-1];
		case 'select':
			var id_array = field.attr('id').split('-');
			return id_array[id_array.length-1];
		case 'multi-select':	
			var id_array = field.attr('id').split('-');
			return id_array[id_array.length-1];
		default:
			return ''
	}
};

/***************************************************************************

  evaluate() does the logical computing between two values with a given
  relationship.

  params [entered_value] - The current value of the input that called the
    change()
  params [relationship] - The relationship of the dependency that the
    input that called the change() is tied to
  params [value] - The value that we are testing against for the dependency
    that the input that called the change() is tied to
  returns [bool] - The boolean value by comparing the entered_value against
    the value using the relationship.

**************************************************************************/

function evaluate(entered_value, relationship, value) {
	switch(relationship)
	{
                /* CHANGE THIS if the model changes on which relationships
                   are allowed.                                           */
		case 'equals':
			return entered_value == value;
		case 'not equals':
			return entered_value != value;
		case 'includes':
			return jQuery.inArray(value, entered_value) != -1;
		case 'not includes':
			return jQuery.inArray(value, entered_value) == -1;
		case 'blank':
			return entered_value == "";
		case 'not blank':
			return entered_value != "";
		default:
			return false;
	}
};

/*************************************************************************

  group_action() responds to the results of evaluate() to enact the
  appropriate action upon the group_field of the dependency_group.

  params [success_flag] - Either set to succeed or failure to indicate
    the results of evaluate()
  params [action] - Either set to show or enable.
  params [group_field] - The field tied to the dependency_group that is
    to experience the action based off of the success of evaluate()
  returns - changes the group_field

*************************************************************************/

function group_action(success_flag, action, group_field) {

	/* CHANGE THIS if the model change on which actions are allowed */

	if (success_flag == true){
		switch(action)
		{
			case 'show':
				$('#input-' + group_field).show();
			case 'enable':
				$('#' + group_field + ' :input').removeAttr('disabled');
		}
	} else {
		switch(action)
		{
			case 'show':
				$('#input-' + group_field).hide();
			case 'enable':
				$('#' + group_field + ' :input').attr('disabled', true);
		}
	}
};

function grab_value(field, type) {
	switch(type)
	{
		case 'text':
			return field.attr('value').toLowerCase();
		case 'radio':
			if (field.val() == $(':checked').val())
			{
				field_val = field.attr('id').split('-').slice(2);
				return field_val.join(" ").toLowerCase();
			}
		case 'textarea':
			return field.val();
		case 'checkbox':
			var value_ray = [];
			var field_ray = [];
			var sibling_ray = field.closest('div').children().children();
			var checked_ray = $('input:checked');
			value_ray = getIntersect(sibling_ray, checked_ray) 
			for (var element in value_ray) {
				field_ray.push(value_ray[element].id.split('-').slice(2)[0]);
			}
			return field_ray;
		case 'select':
			return $('#' + field.attr('id') + ' option:selected').text().toLowerCase();
		case 'multi-select':
			var value_ray = $('#' + field.attr('id') + ' option:selected');
			var field_ray = []
			for (var element in value_ray)
			{
				var temp = value_ray[element].text;
				if (typeof(temp) == "string") { field_ray.push(temp.toLowerCase()); }
			}
			return field_ray;
		default:
			return '';
	}
};

function grab_type(field) {
	if (field.attr('type') != undefined)
	{
		return field.attr('type')
	}
	else if ($('textarea#'+field.attr('id')).length > 0)
	{
		return "textarea";
	}
	else if ($('select#'+field.attr('id')).length > 0)
	{
		if (field.attr('multiple') == "multiple")
		{
			return "multi-select";
		}
		else {
			return "select";
		}
	}
	else
	{
		return "invalid";
	}
}

function getIntersect(arr1, arr2) {
    var temp = [];
    for(var i = 0; i < arr1.length; i++){
        for(var k = 0; k < arr2.length; k++){
            if(arr1[i] == arr2[k]){
                temp.push( arr1[i]);
                break;
            }
        }
    }
    return temp;
}

/***********************************************************************
 
  This watches for ANY change that may take place on the page. It then
  pushes the object through grab_fsc_id to get an id we can check against
  the json_holder. If it's in there, it then grabs all the related data,
  checks the current value against the expected value through the 
  evaluate() function and then goes through the needed action AFTER
  checking each dependency and dependency_clause.
 
***********************************************************************/

allInputs.change( function() {
	var field = $(this);
	var type = grab_type(field);
	var fieldset_child_id = grab_fsc_id(field, type);
	var entered_value = grab_value(field, type)
	if (fieldset_child_id in json_holder) {
		for (var group in json_holder[fieldset_child_id]) {
			var action = json_holder[fieldset_child_id][group]['action'];
			var group_fsc_id = json_holder[fieldset_child_id][group]['fieldset_child_id'];
			var group_field_id = json_holder[fieldset_child_id][group]['field_id'];
			var group_field = 'field-' + group_field_id + '-child-' + group_fsc_id;

			// As each dependency clause is AND'd together, we'll assume it'll be
			// true until short circuited into being false.`
			var group_break_flag = true;
			group:
			for (var clause in json_holder[fieldset_child_id][group]["clause"]) {
				// As each clause ORs dependencies together, we'll assume it'll be
				// false until short circuited into being true.
				var clause_break_flag = false;
				clause:
				for (var dependency in json_holder[fieldset_child_id][group]["clause"][clause])
				{
					var relationship = json_holder[fieldset_child_id][group]["clause"][clause][dependency]['relationship'];
					var value = json_holder[fieldset_child_id][group]["clause"][clause][dependency]['value'].toLowerCase();
					// Short circuit from looking at each dependency in the case
					// we determine a true dependency (OR)
					if (evaluate(entered_value, relationship, value)) {
						clause_break_flag = true;
						break clause;
					}
				}

				// Short circuit from looking at each clause in the case we determine
				// a false dependency (AND)
				if (clause_break_flag == false) {
					group_break_flag = false;
					break group;
				}
			}
			// If successful, group_break_flag will pass true into group_action
			group_action(group_break_flag, action, group_field);
			
		}

	}

})
.change();

</script>
