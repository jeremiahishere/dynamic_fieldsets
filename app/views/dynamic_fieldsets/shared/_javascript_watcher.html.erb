<script type='text/javascript'>

// The only inputs we care about are visible... not hidden
var all_inputs = $(":input:not(:hidden)");

//Return the fieldset child id for the input
//This uniquely associated the fieldset child with the fieldset associator
//New fields should use the fieldset_child_id data attribute
//But older fields can still attempt to parse it out of the id of the dom element
//
// field: Field dom element from dynamic fieldsets
// type: The type of element from get_type
// return: The fieldset child id of the field
function get_fieldset_child_id(field, type) {
  if(typeof(field.attr("data-fsc_id")) != "undefined")  {
    return field.attr("data-fsc_id")
  } else  {
    switch(type)
    {
      case 'text':
      case 'textarea':
      case 'select':
      case 'multi-select':	
        var id_array = field.attr('id').split('-');
        return id_array[id_array.length-1];
      case 'radio':
      case 'checkbox':
        var id_array = field.closest("div").attr("id").split('-');
        return id_array[id_array.length-1];
      default:
        return ''
    }
  }
}

// Pulls the fieldset associator id from the data attribute
// And falls back on the the string between '-' and '_' at the beginning of the id
function get_fieldset_associator_id(field)  {
  if(typeof(field.attr("data-fsa_id")) != "undefined")  {
    return field.attr("data-fsa_id")
  } else {
    //format should be fsa-###_field-###
    return field.attr('id').split("_")[0].split("-")[1]
  }
}

//Determines whether the dependency has been satisfied
//CHANGE THIS if the dependency model changes which relationships are allowed.
//
// user_value: The value on the form
// stored_value: The value that satisfies the dependency
// relationship: The predicate used to compare the user and stored values
//
// returns the result of the relationship between user and stored valued
function evaluate_dependency(user_value, relationship, stored_value) {
	switch(relationship)
	{
		case 'equals':
			return user_value == stored_value;
		case 'not equals':
			return user_value != stored_value;
		case 'includes':
			return $.inArray(stored_value, user_value) != -1;
		case 'not includes':
			return $.inArray(stored_value, user_value) == -1;
		case 'blank':
			return user_value == "";
		case 'not blank':
			return user_value != "";
		default:
			return false;
	}
};

// What to do to the field based on the dependency information
// CHANGE THIS if the dependency group model changes which actions are allowed
//
// success_flag: whether the dependency group returned true or false
// action: the type of update to apply to the field
// group_field: the field to update (generally not the field that triggered the change)
function dependency_action(success_flag, action, group_field) {

	if (success_flag){
		switch(action)
		{
			case 'show':
				$('#input-' + group_field).show();
			case 'enable':
				$('#' + group_field + ' :input').removeAttr('disabled');
		}
	} else {
		switch(action)
		{
			case 'show':
				$('#input-' + group_field).hide();
			case 'enable':
				$('#' + group_field + ' :input').attr('disabled', true);
		}
	}
};

function get_input_value(field, type) {
	switch(type)
	{
		case 'text':
		case 'textarea':
			return field.val();
		case 'radio':
			if (field.attr('checked') == 'checked') {
        return $.trim(field.parent('label').text());
			}
		case 'checkbox':
      return $('input[name="' + field.attr('name') + '"]:checked').map(function(index,option) { 
        return $.trim($(option).parent('label').text())
      });
		case 'select':
			return field.find(':selected').text();
		case 'multi-select':
      return field.find(':selected').map(function(index, option)  {
        return $(option).text();
      });
		default:
			return '';
	}
};

//returns the input type for the field
//this code is necessary to handle text areas and multiple selects
function get_field_type(field) {
	if (field.attr('type') != undefined) {
		return field.attr('type')
	} else if ($('textarea#'+field.attr('id')).length > 0) {
		return "textarea";
	} else if ($('select#'+field.attr('id')).length > 0) {
		if (field.attr('multiple') == "multiple") {
			return "multi-select";
		} else {
			return "select";
		}
	} else {
		return "invalid";
	}
}

// when a dynamic fieldsets field fires a change event,
// update the page based on dependency information
//
// the dependency information is stored in dynamic_fieldsets_dependencies
all_inputs.change( function() {
	var field = $(this);
	var type = get_field_type(field);
	var fieldset_child_id = get_fieldset_child_id(field, type);
  var fieldset_associator_id = get_fieldset_associator_id(field);
	var user_input = get_input_value(field, type)


	if (fieldset_child_id in dynamic_fieldsets_dependencies) {
    $.each(dynamic_fieldsets_dependencies[fieldset_child_id], function(index, group)  {
      update_dependency_group_for_fieldset_child(group, user_input, fieldset_associator_id);
    });
  }
});

// checks the clauses for a dependency group and runs the action
// group: the dependency group
// user_input: the input from the form
function update_dependency_group_for_fieldset_child(group, user_input, fieldset_associator_id)  {
  var action = group['action'];
  var group_fsc_id = group['fieldset_child_id'];
  var group_field_id = group['field_id'];
  var group_field = '<%= DynamicFieldsets.config.form_fieldset_associator_prefix %>' + fieldset_associator_id + '_' + '<%=DynamicFieldsets.config.form_field_prefix %>' + group_fsc_id;
  
  dependency_action(all_dependency_clauses_true(group, user_input), action, group_field)
}

//all dependencies must be satisfied
//the first one that is false makes this return false
//only return true if all return true
function all_dependency_clauses_true(group, user_input)  {
  for(var key in group["clause"])  {
    var clause = group["clause"][key]
    if(!at_least_one_dependency_true(clause, user_input))  {
      return false;
    }
  }
  return true;
}

//The dependencies are ORed together
//So as soon as one returns true, return true
//Only return false if all are false
function at_least_one_dependency_true(clause, user_input)  {
  for(var key in clause)  {
    var dependency = clause[key]
    if(evaluate_dependency(user_input, dependency["relationship"], dependency["value"])) {
      return true
    }
  }
  return false
}

all_inputs.change();

</script>
